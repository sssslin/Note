# 简单工厂模式(静态工厂方法模式)

根据单一职责原则:工厂类只负责创建对象,不负责对象的使用

要点:根据传入的参数不同,创建不同的对象,核心是工厂类的设计(静态工厂方法)



角色:

1工厂角色:负责实现创建所有实例的内部逻辑

2抽象产品角色:是所创建的所有对象的父类,负责描述所有实例所共有的公共接口

3具体产品角色:所有创建的对象都充当这个角色的某个具体类的实例(继承或者实现抽象产品角色)



缺点:如果增加新的业务逻辑,需要修改静态工厂方法的业务逻辑,违反开闭原则



# 工厂方法模式(工厂模式/虚拟构造器模式/多态工厂模式)

角色:

抽象产品:定义产品的接口,是工厂方法模式所创建对象的超类型,也就是产品对象的公共父类

具体产品:实现了抽象产品接口,某种类型的具体产品由专门的具体工厂创建,具体工厂和具体产品之间一一对应

抽象工厂:在抽象工厂类中,声明了工厂方法,用于返回一个产品,抽象工厂是工厂方法模式的核心,所有创建对象的工厂类都必须实现该接口

具体工厂:它是抽象工厂的子类,实现了抽象工厂方法中定义的工厂方法,并可由客户端调用,返回一个具体的产品实例



缺点:添加新产品时,类的数量成对增加

优点:

适用场景:

基于何种需求产生



# 抽象工厂模式

产品族:产品族是指由同一个工厂生产的,位于不同产品等级结构中的一组产品

产品等级:产品等级结构即产品的继承结构



# 原型模式

原型模式:使用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象

原型模式的工作原理:将一个原型对象传给那个要发动创建的对象,这个要发动创建的

对象通过请求原型对象拷贝自己来实现创建过程



抽象原型类:它是声明克隆方法的接口,是所有具体原型类的父类,可以是抽象类,也可以是

接口,甚至还可以是具体实现类.

具体原型类:它实现在抽象原型中声明的克隆方法,在克隆方法中返回自己的一个克隆对象

客户类:让一个原型对象克隆自身从而创建一个新的对象,在客户类中只需要直接实例化或者通过

工厂方法等方式创建一个原型对象,再通过调用该对象的克隆方法即可得到多个相同的对象,

由于客户类针对抽象原型类编程,因此用户可以根据需要选择具体原型类,系统具有良好的扩展性,

增加或者更换具体原型类都很方便

核心:如何实现克隆方法

原型模式:深克隆和浅克隆

区别:是否支持引用类型的成员变量的复制

实现深克隆的方式:序列化

原型管理器:将多个原型对象存储在一个集合中供客户端使用,它是专门负责克隆对象

的工厂,其中定义了一个集合用于存储原型对象,如果需要某个原型对象的一个克隆,

可以通过复制集合中对应的原型对象来获得.在原型管理器中针对抽象原型类进行编程,

以便扩展

# 建造者模式

建造者模式:将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示.

抽象建造者:它为创建一个产品Product对象的各个部件指定抽象接口,	在该接口中一般

声明两类方法,一类方法是buildPartX().他们勇于创建复杂对象的各个部件,另一类方法是

getResult(),他们勇于返回复杂对象.Builder既可以是抽象类,也可以是接口.



具体建造者:它实现了builder接口,实现各个部件的具体构造和装配方法,定义并明确它所

创建的复杂对象,也可以提供一个方法返回创建好的复杂对象.



产品角色:他是被构造的复杂对象,包含多个组成部件,具体建造者创建该产品的内部表示

并定义他的装配过程



指挥者:指挥者又称为导演类,他负责安排复杂对象的建造次序,指挥者与抽象建造者之间存在关联关系,可以在其construction()建造方法中调用建造者对象的部件构造与装配方法,完成复杂对象的建造.

客户端一般只需要与指挥者进行交互,在客户端确定具体建造者的类型,并实例化具体建造者对象

(也可以通过配置文件和反射机制),然后通过指挥者类的构造函数或者

Setter方法将该对象传入指挥者类中.





