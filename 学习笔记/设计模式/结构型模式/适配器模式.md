# 适配器模式

将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类也可以一起工作，其别名为包装器（wrapper），

适配器模式既可以作为类结构型模式，也可以作为对象结构型模式



根据适配器类与适配器者的关系不同，适配器模式可分为对象适配器和类适配器两种，`在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系`。在实际开发中，对象适配器的使用评率更高。



Target(目标抽象类):目标抽象类定义用户所需接口,可以是一个抽象类或接口,也可以是具体类.



Adapter(适配器类):适配器可以调用欧冠另一个接口,作为一个转换器,对Adaptee和Target进行适配,适配器类是适配器模式的核心.在对象适配器中,他通过继承Target并关联一个Adaptee对象使二者产生联系.



Adaptee(适配者类):适配者即被适配的角色,它定义了一个已经存在的接口,这个接口需要适配,适配者类一般是一个具体类,包含了客户希望使用的业务方法,在某些情况下可能没有适配者类的源代码

双向适配器:在实际开发过程中使用的比较少

## 缺省适配器

缺省适配器是适配器模式的一种变体,其应用也较为广泛.

缺省适配器模式:当不需要事先实现一个接口所提供的所有方法时,可以先设计一个抽象类实现该接口,并为接口中每个方法提供一个默认实现(空方法),那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求,它适用于不想使用一个接口中的所有方法的情况,又称为单接口适配器模式



ServiceInterface(适配者接口)：它是一个接口,通常在该接口中声明了大量的方法.



AbstractServiceClass(缺省适配器类):它是缺省适配器模式的核心类,使用空方法的形式实现了再ServiceInterface接口中声明的方法.通常将它定义为抽象类,因为对他进行实例化没有任何意义



ConcreteServiceClass(具体业务类):它是缺省适配器类的子类,在没有引入适配器之前,它需要实现适配者接口,因此需要实现在适配者接口中定义的所有方法,而对于一些无须使用的方法也不得不提供空实现.在有了缺省适配器之后,可以直接继承该适配器类,根据需要有选择性地覆盖在适配器类中定义的方法



适配器模式总结：

适配器模式将现有接口转化为客户类所期望的接口，实现了对现有类的复用，它是一种使用频率非常高的设计模式，在软件开发中得以广泛应用，在Spring等开元框架、驱动程序设计（如JDBC中的数据库驱动程序）中也使用了适配器模式