# 装饰模式

装饰模式是一种用于替代继承的技术，它通过一种无需定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能。



装饰模式（Decorator Pattern）:动态地给一个对象增加一些额外的职责,就增加对象功能来说,装饰模式比生成子类实现更为灵活.装饰模式是一种对象结构模式



Component(抽象构件):它是具体构件和抽象装饰类的共同父类,声明了在具体构件中实现的业务方法,他的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰后的对象,实现客户端的透明操作.



ConcreteComponent(具体构件):它是抽象构件的子类,用于给具体构件增加职责,但是具体职责在其子类中实现.它维护一个指向抽象构件的引用,通过该引用可以调用装饰之前构件对象的方法,并通过其子类扩展该方法,以达到装饰的目的.



ConcreteDecorator(具体装饰类):它是抽象装饰类的子类,负责向构件添加新的职责.每一个具体装饰类都定义了一些新的行为.它可以调用在抽象装饰类中定义的方法,并可以增加新的方法以扩充对象的行为.



在实际使用过程中,由于新增行为可能需要单独调用,因此这种行为的装饰模式也经常出现,这种装饰模式被称为半透明装饰模式,而标准的装饰模式是透明装饰模式



透明装饰模式:

在透明装饰模式中,要求客户端完全针对抽象编程,装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型,而应该全部声明为抽象构件类型,对于客户端而言,具体构件对象和具体装饰对象没有任何区别



半透明装饰模式:

透明装饰模式的设计难度较大，而且有时我们需要单独调用新增的业务方法。**为了能够调用到新增方法，我们不得不用具体装饰类型来定义装饰之后的对象，而具体构件类型还是可以使用抽象构件类型来定义，这种装饰模式即为半透明装饰模式，也就是说，对于客户端而言，具体构件类型无须关心，是透明的；但是具体装饰类型必须指定，这是不透明的** 



半透明装饰模式可以给系统带来更多的灵活性，设计相对简单，使用起来也非常方便；但是其最大的缺点在于不能实现对同一个对象的多次装饰，而且客户端需要有区别地对待装饰之前的对象和装饰之后的对象。 