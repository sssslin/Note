# 职责链模式

职责链可以是一条直线，一个环或者一个树形结构，最常见多的职责链是直线型，即沿着一条单向的链来传递请求。



职责链模式：避免请求发送者与接受者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，知道有对象处理它为止



职责链模式结构的核心在于引入了一个抽象处理者。

Handler(抽象处理者)：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象，作为其对下家的引用，通过该引用，处理者可以成一条链。



ConcreteHandler(具体处理者):它是抽象处理者的子类,可以处理用户请求,在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法,在处理请求之前需要进行判断,看是否有相应的处理权限,如果可以处理请求就处理它,否则将请求转发给后继者;在具体处理者中可以访问链中下一个对象,以便请求的转发



具体处理者的作用:

1.处理请求,不同的具体处理者以不同的形式实现抽象请求处理方法handleRequest();

2.转发请求,如果该请求超出了当前处理者的权限,可以将请求转发给下架



## (1) 纯的职责链模式

一个纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个：要么承担全部责
任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后
又将责任向下传递的情况。而且在纯的职责链模式中，要求一个请求必须被某一个处理者对
象所接收，不能出现某个请求未被任何一个处理者对象处理的情况。在前面的采购单审批实
例中应用的是纯的职责链模式。

## (2)不纯的职责链模式

在一个不纯的职责链模式中允许某个请求被一个具体处理者部分处理后再向下传递，或者一
个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不
被任何处理者对象所接收。Java AWT 1.0中的事件处理模型应用的是不纯的职责链模式，其基
本原理如下：由于窗口组件（如按钮、文本框等） 一般都位于容器组件中，因此当事件发生
在某一个组件上时，先通过组件对象的handleEvent()方法将事件传递给相应的事件处理方法，
该事件处理方法将处理此事件，然后决定是否将该事件向上一级容器组件传播；上级容器组
件在接到事件之后可以继续处理此事件并决定是否继续向上级容器组件传播，如此反复，直
到事件到达顶层容器组件为止；如果一直传到最顶层容器仍没有处理方法，则该事件不予处
理。每一级组件在接收到事件时，都可以处理此事件，而不论此事件是否在上一级已得到处
理，还存在事件未被处理的情况。显然，这就是不纯的职责链模式，早期的Java AWT事件模
型(JDK 1.0及更早)中的这种事件处理机制又叫事件浮升(Event Bubbling)机制。从Java.1.1以
后，JDK使用观察者模式代替职责链模式来处理事件。目前，在JavaScript中仍然可以使用这
种事件浮升机制来进行事件处理。 